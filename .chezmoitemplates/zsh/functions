
# ============================================
# Keybindings & ZLE Widgets
# ============================================
function smart_fg_or_nvim() {
  if [[ $(jobs | wc -l) -gt 0 ]]; then
    fg
  else
    nvim $(tv)
  fi
}
zle -N smart_fg_or_nvim
bindkey '^Z' smart_fg_or_nvim

dxr() {
  # Capture the selected script in a local variable
  local script
  script=$(fd "devbox.json" -x jq -r '.shell.scripts | keys[]' {} 2>/dev/null | fzf --header "Select Devbox Script" --tmux)

  # Check if the variable is non-empty before executing the command
  if [ -n "$script" ]; then
    devbox run "$script"
  fi
}
zle -N dxr-widget dxr
bindkey '^A' dxr-widget

function mdcp() {
  local url="$1"
  if [ -z "$url" ]; then
    gum log --level error "Please provide a URL"
    return 1
  fi
  markitdown "$url" | copy
}

fdcd() {
  local dir
  dir=$(
    cd &&
      fd -0 --type d --ignore-file ~/.config/fd/ignore --hidden |
      fzf --read0
  ) && cd ~/$dir
}

# Function to change directory to a git worktree selected with fzf
function gws() {
  # Use `local` to keep variables from polluting the global shell environment.
  local selected_line
  local worktree_path

  # Get the full line selected from fzf.
  # The `|| return` part ensures that if fzf is cancelled (returns a non-zero exit code),
  # the function exits gracefully.
  selected_line=$(git worktree list | fzf --height 30% --reverse) || return

  # Use awk to extract the path by removing the last two columns (commit and branch).
  # This correctly handles paths that contain spaces.
  worktree_path=$(printf "%s" "$selected_line" | awk '{$NF=""; $(NF-1)=""; sub(/ *$/, ""); print}')
  
  # Change to the selected directory.
  # The `cd` command is now running in your main shell, not a subshell.
  cd "$worktree_path"
}

function y() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
	yazi "$@" --cwd-file="$tmp"
	if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
		builtin cd -- "$cwd"
	fi
	rm -f -- "$tmp"
}
zle -N y-widget y
bindkey '^.' y-widget

# ============================================
# Directory Navigation
# ============================================
function c.() {
	cd "$(tv ghq)"
}

function e.() {
  cd "$(tv ghq)"
  nvim
}

function open_repo() {
  cd $(tv ghq)
  clear
}
zle -N open_repo-widget open_repo
bindkey '^O' open_repo-widget

# ============================================
# TV (Television) Functions
# ============================================
function t.() {
  # Get all channels (both builtin and custom)
  BUILTIN_CHANNELS=$(tv list-channels | grep -A 100 "Builtin channels:" | grep -B 100 "Custom channels:" | grep -v "Builtin channels:" | grep -v "Custom channels:" | awk '{print $1}' | tr -d ' ')
  CUSTOM_CHANNELS=$(tv list-channels | grep -A 100 "Custom channels:" | awk '{print $1}' | tr -d ' ')
  
  # Combine all channels and sort alphabetically
  ALL_CHANNELS=$(echo "$BUILTIN_CHANNELS\n$CUSTOM_CHANNELS" | grep -v '^$' | sort)
  
  # Let user select a channel using gum
  CHANNEL=$(echo "$ALL_CHANNELS" | gum filter)
  
  if [ -z "$CHANNEL" ]; then
    gum log --level error "No channel selected. Exiting."
    return 1
  fi
  
  # Handle different channels
  case "$CHANNEL" in
    # Bookmarks - open in browser
    "bmm")
      {{ if eq .chezmoi.os "darwin" -}}
      open $(tv bmm)
      {{ else -}}
      xdg-open $(tv bmm)
      {{ end -}}
      ;;
    
    # Project directories - change to directory
    "ghq" | "git-repos" | "dirs")
      cd "$(tv $CHANNEL)"
      ;;
    
    # Environment variables - display with pager and copy selected to clipboard
    "env")
      ENV_VAR=$(tv env | gum filter)
      if [ -n "$ENV_VAR" ]; then
        {{ if eq .chezmoi.os "darwin" -}}
        echo "$ENV_VAR" | awk -F= '{print $2}' | tr -d '\n' | pbcopy
        gum log --level info "Copied value to clipboard: $(pbpaste)"
        {{ else -}}
        echo "$ENV_VAR" | awk -F= '{print $2}' | tr -d '\n' | xclip -selection clipboard
        gum log --level info "Copied value to clipboard"
        {{ end -}}
      fi
      ;;
    
    # Text content - display with gum pager
    "text" | "md" | "git-log" | "git-reflog" | "git-diff" | "fish-history" | "zsh-history" | "bash-history")
      tv "$CHANNEL" | gum pager
      ;;
    
    # Task management
    "task")
      tv task | xargs task
      ;;
    
    # Projects - open in nvim
    "js" | "swift" | "go" | "proto" | "templ" | "css" | "pkl" | "my-dotfiles")
      nvim $(tv "$CHANNEL")
      ;;
    
    # Default - open in nvim
    *)
      gum pager $(tv "$CHANNEL")
      ;;
  esac
}

function tv_channels() {
  tv list-channels | sed -n '/Custom channels:/,$p' | grep -v "Custom channels:" | sed 's/^[[:space:]]*//' | grep -v "^$" | sort
}

# TV Channel Selector - ZLE widget
function tv-channel-select() {
    local selected_channel
    
    # Get channel list and select with fzf
    selected_channel=$(tv channels | fzf --height=40% --reverse --prompt="Select TV Channel: ")
    
    # If a channel was selected
    if [[ -n "$selected_channel" ]]; then
        # Extract channel name without parentheses and type
        local channel_name=$(echo "$selected_channel" | sed 's/ (.*)//')
        
        # Clear current line and insert tv command
        BUFFER="tv --channel $channel_name"
        zle accept-line
    fi
    
    # Redraw prompt
    zle reset-prompt
}
zle -N tv-channel-select
bindkey '^P' tv-channel-select

# ============================================
# Bookmark Management (BMM)
# ============================================
function bdel() {
  bmm delete $(tv bmm) --yes
}

function b.() {
  {{ if eq .chezmoi.os "darwin" -}}
  open $(tv bmm)
  {{ else -}}
  xdg-open $(tv bmm)
  {{ end -}}
}

# ============================================
# Git & GitHub Functions
# ============================================
function gog() {
  gum spin --title "Fetching $1..." -- ghq get git.sonr.io/$1
  gum spin --title "Adding $1..." -- zoxide add $GHQ_ROOT/git.sonr.io/$1
}

function ghg() {
  gum spin --title "Fetching $1..." -- ghq get $1
  gum spin --title "Adding $1..." -- zoxide add $GHQ_ROOT/github.com/$1
}

function gogu() {
    # List all repositories under onsonr.dev and update each one
    for repo in $(ghq list | grep "^git.sonr.io/"); do
        gum spin --spinner dot --title "Fetching $repo..." -- ghq get -u $repo
        gum log --level info "[Fetched] $repo âœ…"
    done
}

function ghgu() {
    # List all repositories under github.com and update each one
    for repo in $(ghq list | grep "^github.com/"); do
        gum spin --spinner dot --title "Fetching $repo..." -- ghq get -u $repo
        gum log --level info "[Fetched] $repo âœ…"
    done
}

function ghn() {
  ORG_NAME=$(gum choose --header "Select parent org:" "sonr-io" "prnk28" "go-sonr" "gpm-tools" "pkl-sh")
  REPO_NAME=$(gum input --header "Enter a name for your new repo")
  if [ -z "$REPO_NAME" ]; then
    gum log --level error "Please enter a valid name for the repo and organization."
    return 1
  fi
  gh repo create $ORG_NAME/$REPO_NAME --private
  ghg $ORG_NAME/$REPO_NAME
  cd {{ .chezmoi.homeDir }}/Developer/github.com/$ORG_NAME/$REPO_NAME
}

function gop() {
  local repo=$(basename $PWD)
  
  if [[ "$repo" == ".dotfiles" ]]; then
    local url="https://github.com/prnk28/.dotfiles"
    {{ if eq .chezmoi.os "darwin" -}}
    open "$url"
    {{ else -}}
    xdg-open "$url"
    {{ end -}}
  else
    local host=$(basename $(dirname $(dirname $PWD)))
    local org=$(basename $(dirname $PWD))
    
    local url="https://$host/$org/$repo"
    {{ if eq .chezmoi.os "darwin" -}}
    open "$url"
    {{ else -}}
    xdg-open "$url"
    {{ end -}}
  fi
}

function ghdocdl() {
  # Check if a repository URL or name is provided
  if [ -z "$1" ]; then
    gum log --level error "Please provide a GitHub repository URL or name"
    return 1
  fi

  # Extract repository name from the input
  local repo=$(echo "$1" | sed 's/.*\///')
  
  # Create destination directory
  local dest_dir="{{ .chezmoi.homeDir }}/Downloads/$repo-docs"
  mkdir -p "$dest_dir"
  gum log --level info "Created destination directory" path "$dest_dir"
  
  # Create and navigate to temporary directory
  local temp_dir=$(mktemp -d)
  cd "$temp_dir" || { 
    gum log --level error "Failed to navigate to temporary directory"
    return 1
  }
  gum log --level debug "Created temporary directory" path "$temp_dir"
  
  # Clone the repository
  gum log --level info "Cloning repository" repo "$1"
  gum spin --spinner dot --title "Cloning $1..." -- gh repo clone "$1" || { 
    gum log --level error "Failed to clone repository" repo "$1"
    rm -rf "$temp_dir"
    return 1
  }
  
  # Navigate to the cloned repository
  cd "$repo" || { 
    gum log --level error "Failed to navigate to repository directory" repo "$repo"
    rm -rf "$temp_dir"
    return 1
  }
  
  # Copy markdown files to destination
  gum log --level info "Copying documentation files to destination"
  if command -v fd >/dev/null 2>&1; then
    gum spin --spinner dot --title "Copying markdown files..." -- \
      fd -e md -x cp -v {} "$dest_dir"
  else
    gum spin --spinner dot --title "Copying markdown files..." -- \
      find . -name "*.md" -exec cp -v {} "$dest_dir" \;
  fi
  
  # Clean up and navigate to destination
  cd "{{ .chezmoi.homeDir }}" || return 1
  gum spin --spinner dot --title "Cleaning up..." -- rm -rf "$temp_dir"
  gum log --level info "Documentation downloaded successfully" path "$dest_dir"
  cd "$dest_dir" || return 1
  gum log --level info "Current directory" path "$PWD"
}

function rga() {
  local rg_command=$(git ls-files | mods "$(gum input --header 'What would you like to filter by?')" -R rg-assistant -f bash -r)
  gum confirm "Do you want to run the command?" || return
  eval "$rg_command"
}

# ============================================
# Development Tools
# ============================================
function trc() {
  ORG_NAME=$(gum choose --header "Select parent org:" "apps" "core" "env" "libs" "ops" "pkg" "sink" "vm")
  if [ -z "$ORG_NAME" ]; then
    gum log --level error "Please choose a valid organization."
    return 1
  fi

  REPO_NAME=$(gum input --header "Enter a name for your new repo")
  if [ -z "$REPO_NAME" ]; then
    gum log --level error "Please enter a valid name for the repo and organization."
    return 1
  fi

  tea repo create --name "$REPO_NAME" --owner "$ORG_NAME"
}

function inf() {
  INFISICAL_API_URL="https://secrets.gitsonr.io/api"
  infisical $1
}

function run_make() {
  tv make | xargs make
}

function find_files() {
  FILE_TYPE=$(gum choose "go" "js" "py" "md" "docker")
  if [ -z "$FILE_TYPE" ]; then
    return
  fi
  nvim $(tv $FILE_TYPE)
}
zle -N find_files-widget find_files
bindkey '^F' find_files-widget

# ============================================
# Docker Functions
# ============================================

function docker-nuke() {
  echo "ðŸš¨ WARNING: This will stop and remove all non-essential Docker containers, volumes, and images ðŸš¨"
  echo "Press Ctrl+C to abort or Enter to continue..."
  read

  echo "ðŸ›‘ Stopping all non-essential containers..."
  docker ps -a --format '{{ "{{.Names}}" }}' | grep -v 'k8s\|buildkit' | xargs -r docker stop

  echo "ðŸ—‘ï¸ Removing all non-essential containers..."
  docker ps -a --format '{{ "{{.Names}}" }}' | grep -v 'k8s\|buildkit' | xargs -r docker rm

  echo "ðŸ§¹ Removing all unused networks..."
  docker network prune -f

  echo "ðŸ’¾ Removing all volumes..."
  docker volume rm $(docker volume ls -q) 2>/dev/null || echo "No volumes to remove."

  echo "ðŸ–¼ï¸ Removing all images..."
  docker rmi $(docker images -q) -f 2>/dev/null || echo "No images to remove."

  echo "ðŸ§¼ Performing system prune to clean up any remaining resources..."
  docker system prune -af --volumes

  echo "âœ… Docker environment has been nuked! Only Kubernetes and BuilderKit related resources remain."
}

function docker-compose-up() {
  local compose_file="$1"
  
  if [[ -z "$compose_file" ]]; then
    echo "Error: No compose file provided"
    return 1
  fi
  
  if gum confirm "Run in detached mode?"; then
    echo "Running in detached mode..."
    docker compose -f "$compose_file" up -d
  else
    echo "Running in attached mode..."
    docker compose -f "$compose_file" up
  fi
}

# ============================================
# Go Functions
# ============================================
function go-nuke() {
  echo "ðŸš¨ WARNING: This will clean your Go module cache and {{ .chezmoi.homeDir }}/go directory ðŸš¨"
  echo "Press Ctrl+C to abort or Enter to continue..."
  read

  echo "ðŸ§¹ Cleaning Go module cache..."
  go clean -modcache

  echo "ðŸ§¼ Cleaning Go build cache..."
  go clean -cache

  echo "ðŸ—‘ï¸ Cleaning Go test cache..."
  go clean -testcache

  echo "ðŸ“¦ Removing downloaded modules in {{ .chezmoi.homeDir }}/go/pkg/mod..."
  rm -rf {{ .chezmoi.homeDir }}/go/pkg/mod/* 2>/dev/null || echo "No modules to remove."

  echo "ðŸ”¨ Removing compiled binaries in {{ .chezmoi.homeDir }}/go/bin..."
  rm -rf {{ .chezmoi.homeDir }}/go/bin/* 2>/dev/null || echo "No binaries to remove."

  echo "ðŸ§ª Removing test results..."
  find {{ .chezmoi.homeDir }}/go -name "*.test" -type f -delete

  echo "ðŸ—„ï¸ Removing temporary build files..."
  find {{ .chezmoi.homeDir }}/go -name "*.o" -type f -delete
  find {{ .chezmoi.homeDir }}/go -name "*.a" -type f -delete
  find {{ .chezmoi.homeDir }}/go -name "*.so" -type f -delete

  echo "âœ… Go environment has been nuked! Your {{ .chezmoi.homeDir }}/go directory is clean."
  echo "ðŸ‘‰ Note: Your source code in {{ .chezmoi.homeDir }}/go/src remains untouched."
}

# ============================================
# Utility Functions
# ============================================
function set_ghq_root() {
  os=$(uname)
  if [ "$os" = "Darwin" ]; then
    export GHQ_ROOT="{{ .chezmoi.homeDir }}/Developer"
  else
    export GHQ_ROOT="{{ .chezmoi.homeDir }}/code"
  fi
}
set_ghq_root

function today_format_date() {
    # Get year
    local year=$(date +%Y)
    # Get week number (01-53)
    local week=$(date +%V)
    # Get day of week (1-7 where Monday is 1)
    local day=$(date +%u)

    # Combine and echo
    echo "${year}.${week}.${day}"
}
alias tdy="today_format_date"

function today() {
    if [[ -n "$1" ]]; then
        # If date provided, parse it
        date -j -f "%Y-%m-%d" "$1" "+%Y.%V.%u" 2>/dev/null || echo "Usage: today [YYYY-MM-DD]"
    else
        # Current date
        date "+%Y.%V.%u"
    fi
}

function tmux_start() {
    local session_name="$1"
    local command="$2"
    
    # Check if session exists, create new window if it does, or create new session if it doesn't
    tmux has-session -t "$session_name" 2>/dev/null \
        && tmux new-window -t "$session_name:" -c "#{pane_current_path}" "$command" \
        || tmux new-session -d -s "$session_name" -c "#{pane_current_path}" "$command"
}

# ============================================
# Document & Media Functions
# ============================================
function md_html() {
  # Use gum for directory selection but handle errors better
  local input_dir
  input_dir=$(gum file --directory --header "Select the directory containing the markdown files") || {
    echo "Operation canceled."
    return 1
  }
  
  # Check if directory selection was canceled
  if [[ -z "$input_dir" ]]; then
    echo "Operation canceled."
    return 1
  fi
 
  # Check if input directory exists
  if [[ ! -d "$input_dir" ]]; then
    echo "Error: Directory '$input_dir' does not exist."
    return 1
  fi

   # Use gum for output file name with default
  local default_name="output.html"
  local output_file
  output_file=$(gum input --placeholder "$default_name" --header "Enter output HTML filename (or press Enter for $default_name)") || {
    echo "Operation canceled."
    return 1
  }
  output_file="${output_file:-$default_name}" 
 
  # Find markdown files
  echo "Finding markdown files..."
  local md_files=()
  while IFS= read -r line; do
    md_files+=("$line")
  done < <(find "$input_dir" -name "*.md" -o -name "*.markdown")
  
  # Check if any markdown files were found
  if [[ ${#md_files[@]} -eq 0 ]]; then
    echo "Error: No markdown files found in '$input_dir'."
    return 1
  fi
  
  echo "Found ${#md_files[@]} markdown files. Generating HTML..."
  
  # Generate HTML
  pandoc "${md_files[@]}" \
    -f markdown \
    -t html \
    -o "$output_file" \
    --highlight-style=tango \
    --self-contained \
    --metadata title="Markdown Compilation"
  
  if [[ $? -eq 0 ]]; then
    echo "âœ“ HTML successfully created: $output_file"
    
    # Ask if user wants to open the HTML
    echo "Do you want to open the HTML now? (y/n)"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      {{ if eq .chezmoi.os "darwin" -}}
      open "$output_file"
      {{ else if eq .chezmoi.os "linux" -}}
      xdg-open "$output_file" &> /dev/null
      {{ end -}}
    fi
    
    echo "You can convert this HTML to PDF using your browser's print function."
    return 0
  else
    echo "âœ— Error: Failed to create HTML."
    return 1
  fi
}

function pdf2md() {
  FILE=$(gum file --file)
  OUTPUT=$(gum input --header "Output file name (without extension): ")
  if [ -z "$OUTPUT" ]; then
    OUTPUT=$(basename "$FILE" .pdf)
  fi
  # check for file input
  if [ -f "$FILE" ]; then
   gum spin "Generating markdown" -- uvx 'markitdown[all]' "$FILE" -o "$OUTPUT.md"
   cat "$OUTPUT.md" | gum pager
  fi
}

function video_thumbnail_preview() {
  # Create a temporary directory for thumbnails
  local THUMBNAIL_DIR=$(mktemp -d)
  
  # Find all video files recursively
  find "${1:-.}" -type f -name "*.mp4" -o -name "*.mkv" -o -name "*.avi" -o -name "*.mov" -o -name "*.wmv" | while read -r video_file; do
    # Generate a unique thumbnail filename
    local thumbnail_file="$THUMBNAIL_DIR/$(basename "$video_file").jpg"
    
    # Extract thumbnail at 10% of the video duration
    ffmpeg -y -i "$video_file" -ss $(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$video_file" | awk '{print $1*0.1}') -vframes 1 "$thumbnail_file" 2>/dev/null
    
    # Add the video path to a list file with its corresponding thumbnail
    echo "$video_file:$thumbnail_file" >> "$THUMBNAIL_DIR/video_list.txt"
  done
  
  # Use fzf to preview thumbnails and select a video
  local selected_video=$(cat "$THUMBNAIL_DIR/video_list.txt" | fzf --delimiter=":" \
    --preview="kitty icat --clear --transfer-mode=file --place=\${FZF_PREVIEW_COLUMNS}x\${FZF_PREVIEW_LINES}@0x0 {2} 2>/dev/null || \
               catimg {2} 2>/dev/null || \
               chafa {2} 2>/dev/null || \
               echo 'No preview available'" \
    --preview-window="right:50%" \
    --with-nth=1 | cut -d ":" -f1)
  
  # Clean up the temporary directory
  rm -rf "$THUMBNAIL_DIR"
  
  # Return the selected video path
  if [ -n "$selected_video" ]; then
    echo "$selected_video"
  fi
}

function split_csv() {
    # Check if a file was provided
    if [ -z "$1" ]; then
        echo "Usage: split_csv <csv_file> [chunk_size]"
        return 1
    fi
    
    # Set variables
    FILE="$1"
    BASENAME=$(basename "$FILE" .csv)
    
    # Check if file exists
    if [ ! -f "$FILE" ]; then
        echo "Error: File '$FILE' not found"
        return 1
    fi
    
    # Set chunk size (default to 2000 if not specified)
    if [ -n "$2" ]; then
        CHUNK="$2"
    else 
        CHUNK=2000
    fi
    
    # Get the header
    HEADER=$(head -1 "$FILE")
    
    # Create a temporary directory for processing
    TEMP_DIR=$(mktemp -d)
    
    # Split the file (excluding header)
    tail -n +2 "$FILE" | split -l "$CHUNK" - "$TEMP_DIR/${BASENAME}_"
    
    # Add header to each file and rename with proper numbering
    COUNT=1
    for i in "$TEMP_DIR/${BASENAME}_"*; do
        # Create output filename with padding (01, 02, etc.)
        OUTPUT_FILE="${BASENAME}_$(printf "%02d" $COUNT).csv"
        
        # Add header and save to final location
        echo "$HEADER" > "$OUTPUT_FILE"
        cat "$i" >> "$OUTPUT_FILE"
        
        echo "Created: $OUTPUT_FILE"
        COUNT=$((COUNT + 1))
    done
    
    # Clean up temporary files
    rm -rf "$TEMP_DIR"
    
    echo "Split complete: $((COUNT-1)) files created with $CHUNK rows each (except possibly the last file)"
}

function url_preview() {
  if [[ -z "$1" ]]; then
    echo "Usage: url_preview <url>"
    return 1
  fi

  local url="$1"
  local cache_dir="${XDG_CACHE_HOME:-{{ .chezmoi.homeDir }}/.cache}/url_preview"
  local cache_file="$cache_dir/$(echo "$url" | md5sum | cut -d' ' -f1)"
  
  # Create cache directory if it doesn't exist
  mkdir -p "$cache_dir"
  
  # Check if cached result exists and is less than 24 hours old
  if [[ -f "$cache_file" && $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt 86400 ]]; then
    cat "$cache_file"
    return 0
  fi
  
  # Use curl with timeout and limited download
  local html=$(curl -s -L --max-filesize 50000 --connect-timeout 3 --max-time 5 "$url" | 
               grep -A 100 "<head" | grep -B 100 "</head>" 2>/dev/null)
  
  # Extract all metadata in a single pass
  local title=$(echo "$html" | grep -o '<meta property="og:title" content="[^"]*"\|<title>[^<]*</title>' | 
                sed -E 's/<meta property="og:title" content="([^"]*)"|<title>([^<]*)<\/title>/\1\2/' | head -1)
  
  local description=$(echo "$html" | grep -o '<meta property="og:description" content="[^"]*"\|<meta name="description" content="[^"]*"' | 
                      sed -E 's/<meta property="og:description" content="([^"]*)"|<meta name="description" content="([^"]*)"/\1\2/' | head -1)
  
  local labels=$(echo "$html" | grep -o '<meta property="og:keywords" content="[^"]*"\|<meta name="keywords" content="[^"]*"' | 
                 sed -E 's/<meta property="og:keywords" content="([^"]*)"|<meta name="keywords" content="([^"]*)"/\1\2/' | head -1)
  
  local category=$(echo "$html" | grep -o '<meta property="og:type" content="[^"]*"\|<meta name="category" content="[^"]*"' | 
                   sed -E 's/<meta property="og:type" content="([^"]*)"|<meta name="category" content="([^"]*)"/\1\2/' | head -1)
  
  # Set default values if not found
  [[ -z "$title" ]] && title="No title found"
  [[ -z "$description" ]] && description="No description found"
  [[ -z "$labels" ]] && labels="No labels found"
  [[ -z "$category" ]] && category="No category found"
  
  # Format with gum
  local output=$(gum format "# $title" "> $labels" "$description" "### $category")
  
  # Cache the result
  echo "$output" > "$cache_file"
  
  # Output the result
  echo "$output"
}

# ============================================
# Environment Specific
# ============================================
{{ if eq .chezmoi.os "darwin" -}}
export NVM_DIR="{{ .chezmoi.homeDir }}/.nvm"
  [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && \. "/opt/homebrew/opt/nvm/nvm.sh"  # This loads nvm
  [ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"  # This loads nvm bash_completion

if [ -d "/opt/homebrew/opt/ruby/bin" ]; then
  export PATH=/opt/homebrew/opt/ruby/bin:$PATH
  export PATH=`gem environment gemdir`/bin:$PATH
fi

export PATH="/usr/local/opt/libpq/bin:$PATH"
export PATH="/opt/homebrew/opt/libpq/bin:$PATH"
{{ end -}}

# ============================================
# Tmuxinator
# ============================================
alias tts='tmuxinator start $(tmuxinator list | tail -n +2 | tr -s " " "\n" | fzf --reverse --header "Select a tmuxinator session")'

# ============================================
# Task Runner
# ============================================
alias ght='git_root=$(git rev-parse --show-toplevel 2>/dev/null) && taskfile="$git_root/.github/Taskfile.yml" && [ -f "$taskfile" ] && task -t "$taskfile" "$@" || echo "No Taskfile.yml found in .github directory of git repository"'

# ============================================
# Completion
# ============================================
{{ if eq .chezmoi.os "darwin" -}}
## [Completion]
## Completion scripts setup. Remove the following line to uninstall
[[ -f {{ .chezmoi.homeDir }}/.config/.dart-cli-completion/zsh-config.zsh ]] && . {{ .chezmoi.homeDir }}/.config/.dart-cli-completion/zsh-config.zsh || true

function sesh-sessions() {
  {
    exec </dev/tty
    exec <&1
    local session
    session=$(sesh list -t -c | fzf --height 40% --reverse --border-label ' sesh ' --border --prompt 'âš¡  ')
    zle reset-prompt > /dev/null 2>&1 || true
    [[ -z "$session" ]] && return
    sesh connect $session
  }
}

zle     -N             sesh-sessions
bindkey -M emacs '\es' sesh-sessions
bindkey -M vicmd '\es' sesh-sessions
bindkey -M viins '\es' sesh-sessions

{{ end -}}

function sshc() {
  gum format "SSH Command on All Servers"
  echo "\n"
  # Get all variables after the command and make into a string
  sshsync all "$(gum input --header "Enter SSH command: ")"
}

function sshb() {
  gum format "# SSH Command on Build Server"
  echo "\n"
  # Get all variables after the command and make into a string
  sshsync group builder "$(gum input --header "Enter SSH command: ")"
}

function ssht() {
  gum format "# SSH Command on Testnet Server"
  echo "\n"
  # Get all variables after the command and make into a string
  sshsync group testnet "$(gum input --header "Enter SSH command: ")"
}

function sshg() {
  gum format "# SSH Command on Gateway Server"
  echo "\n"
  # Get all variables after the command and make into a string
  sshsync group gateway "$(gum input --header "Enter SSH command: ")"
}

function sshr() {
  gum format "# SSH Command on Tool Servers"
  echo "\n"
  # Get all variables after the command and make into a string
  sshsync group tools "$(gum input --header "Enter SSH command: ")"
}

