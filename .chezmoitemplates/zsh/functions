
# ============================================
# Keybindings & ZLE Widgets
# ============================================
function mdcp() {
  local url="$1"
  if [ -z "$url" ]; then
    gum log --level error "Please provide a URL"
    return 1
  fi
  markitdown "$url" | copy
}
# ============================================
# Git & GitHub Functions
# ============================================

function ghg() {
  gum spin --title "Fetching $1..." -- ghq get $1
  gum spin --title "Adding $1..." -- zoxide add $GHQ_ROOT/github.com/$1
}

function ghgu() {
    # List all repositories under github.com and update each one
    for repo in $(ghq list | grep "^github.com/"); do
        gum spin --spinner dot --title "Fetching $repo..." -- ghq get -u $repo
        gum log --level info "[Fetched] $repo âœ…"
    done
}

function ghn() {
  ORG_NAME=$(gum choose --header "Select parent org:" "sonr-io" "prnk28" "go-sonr" "gpm-tools" "pkl-sh")
  REPO_NAME=$(gum input --header "Enter a name for your new repo")
  if [ -z "$REPO_NAME" ]; then
    gum log --level error "Please enter a valid name for the repo and organization."
    return 1
  fi
  gh repo create $ORG_NAME/$REPO_NAME --private
  ghg $ORG_NAME/$REPO_NAME
  cd {{ .chezmoi.homeDir }}/code/github.com/$ORG_NAME/$REPO_NAME
}

function gop() {
  local repo=$(basename $PWD)
  
  if [[ "$repo" == ".dotfiles" ]]; then
    local url="https://github.com/prnk28/.dotfiles"
    {{ if eq .chezmoi.os "darwin" -}}
    open "$url"
    {{ else -}}
    xdg-open "$url"
    {{ end -}}
  else
    local host=$(basename $(dirname $(dirname $PWD)))
    local org=$(basename $(dirname $PWD))
    
    local url="https://$host/$org/$repo"
    {{ if eq .chezmoi.os "darwin" -}}
    open "$url"
    {{ else -}}
    xdg-open "$url"
    {{ end -}}
  fi
}

function ghdocdl() {
  # Check if a repository URL or name is provided
  if [ -z "$1" ]; then
    gum log --level error "Please provide a GitHub repository URL or name"
    return 1
  fi

  # Extract repository name from the input
  local repo=$(echo "$1" | sed 's/.*\///')
  
  # Create destination directory
  local dest_dir="{{ .chezmoi.homeDir }}/Downloads/$repo-docs"
  mkdir -p "$dest_dir"
  gum log --level info "Created destination directory" path "$dest_dir"
  
  # Create and navigate to temporary directory
  local temp_dir=$(mktemp -d)
  cd "$temp_dir" || { 
    gum log --level error "Failed to navigate to temporary directory"
    return 1
  }
  gum log --level debug "Created temporary directory" path "$temp_dir"
  
  # Clone the repository
  gum log --level info "Cloning repository" repo "$1"
  gum spin --spinner dot --title "Cloning $1..." -- gh repo clone "$1" || { 
    gum log --level error "Failed to clone repository" repo "$1"
    rm -rf "$temp_dir"
    return 1
  }
  
  # Navigate to the cloned repository
  cd "$repo" || { 
    gum log --level error "Failed to navigate to repository directory" repo "$repo"
    rm -rf "$temp_dir"
    return 1
  }
  
  # Copy markdown files to destination
  gum log --level info "Copying documentation files to destination"
  if command -v fd >/dev/null 2>&1; then
    gum spin --spinner dot --title "Copying markdown files..." -- \
      fd -e md -x cp -v {} "$dest_dir"
  else
    gum spin --spinner dot --title "Copying markdown files..." -- \
      find . -name "*.md" -exec cp -v {} "$dest_dir" \;
  fi
  
  # Clean up and navigate to destination
  cd "{{ .chezmoi.homeDir }}" || return 1
  gum spin --spinner dot --title "Cleaning up..." -- rm -rf "$temp_dir"
  gum log --level info "Documentation downloaded successfully" path "$dest_dir"
  cd "$dest_dir" || return 1
  gum log --level info "Current directory" path "$PWD"
}

function rga() {
  local rg_command=$(git ls-files | mods "$(gum input --header 'What would you like to filter by?')" -R rg-assistant -f bash -r)
  gum confirm "Do you want to run the command?" || return
  eval "$rg_command"
}

# ============================================
# Development Tools
# ============================================
dxr() {
  # Capture the selected script in a local variable
  local script
  script=$(fd "devbox.json" -x jq -r '.shell.scripts | keys[]' {} 2>/dev/null | fzf --header "Select Devbox Script" --tmux)

  # Check if the variable is non-empty before executing the command
  if [ -n "$script" ]; then
    devbox run "$script"
  fi
}
zle -N dxr-widget dxr
bindkey '^B' dxr-widget

function y() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
	yazi "$@" --cwd-file="$tmp"
	if cwd="$(command cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
		builtin cd -- "$cwd"
	fi
	rm -f -- "$tmp"
  zle && zle reset-prompt  # Force prompt redraw
}
zle -N y-widget y
bindkey '^F' y-widget

function edit_files() {
  if [[ $(jobs | wc -l) -gt 0 ]]; then
    fg
  else
  git ls-files | \
    grep -v -E '\.(pb|twirp)\.go$|_templ\.go$|\.pb\.gw\.go$|_gen\.go$|\.gen\.go$|mock_.*\.go$' | \
    xargs -I {} stat -c "%Y %n" {} 2>/dev/null | \
    sort -rn | \
    cut -d' ' -f2- | \
    fzf --preview 'bat --color=always --style=numbers --line-range=:500 {}' \
        --preview-window=right:60% \
        --bind 'ctrl-/:toggle-preview' \
        --bind 'enter:execute(${EDITOR:-nvim} {})' \
        --header 'ENTER to edit | CTRL-/ to toggle preview'
  fi
  zle && zle reset-prompt  # Force prompt redraw
}

alias e=edit_files
zle -N edit_files-widget edit_files
bindkey '^E' edit_files-widget

function open_lazycommit() {
  /home/prad/.local/bin/gcai
  zle && zle reset-prompt  # Force prompt redraw
}

zle -N open_lazycommit-widget open_lazycommit
bindkey '^G' open_lazycommit-widget
alias gc=open_lazycommit

function open_github-issues() {
  /home/prad/.local/bin/github issues
  zle && zle reset-prompt  # Force prompt redraw
}

zle -N open_github-issues-widget open_github-issues
bindkey '^I' open_github-issues-widget
alias ghi=open_github-issues

function open_github-prs() {
  /home/prad/.local/bin/github prs
  zle && zle reset-prompt  # Force prompt redraw
}

zle -N open_github-prs-widget open_github-prs
bindkey '^P' open_github-prs-widget
alias ghp=open_github-prs

function open_github-actions() {
  /home/prad/.local/bin/github actions
  zle && zle reset-prompt  # Force prompt redraw
}

zle -N open_github-actions-widget open_github-actions
bindkey '^A' open_github-actions-widget
alias gha=open_github-actions

function open_repo() {
  local selected=$(ghq list | fzf --delimiter='/' --nth=-1)
  if [[ -n "$selected" ]]; then
    cd "$GHQ_ROOT/$selected"
    clear
  fi
  zle && zle reset-prompt  # Force prompt redraw
}

zle -N open_repo-widget open_repo
bindkey '^O' open_repo-widget
alias o=open_repo

# ghc widget and key binding
claude_widget() {
  if git rev-parse --is-inside-work-tree &>/dev/null; then
    BUFFER="claude -r --dangerously-skip-permissions"
  else
    BUFFER="open_repo && claude -r --dangerously-skip-permissions"
  fi
  zle accept-line
}
zle -N claude_widget
bindkey '^K' claude_widget
alias /c=claude_widget

# ============================================
# Docker Functions
# ============================================

function docker-nuke() {
  echo "ðŸš¨ WARNING: This will stop and remove all non-essential Docker containers, volumes, and images ðŸš¨"
  echo "Press Ctrl+C to abort or Enter to continue..."
  read

  echo "ðŸ›‘ Stopping all non-essential containers..."
  docker ps -a --format '{{ "{{.Names}}" }}' | grep -v 'k8s\|buildkit' | xargs -r docker stop

  echo "ðŸ—‘ï¸ Removing all non-essential containers..."
  docker ps -a --format '{{ "{{.Names}}" }}' | grep -v 'k8s\|buildkit' | xargs -r docker rm

  echo "ðŸ§¹ Removing all unused networks..."
  docker network prune -f

  echo "ðŸ’¾ Removing all volumes..."
  docker volume rm $(docker volume ls -q) 2>/dev/null || echo "No volumes to remove."

  echo "ðŸ–¼ï¸ Removing all images..."
  docker rmi $(docker images -q) -f 2>/dev/null || echo "No images to remove."

  echo "ðŸ§¼ Performing system prune to clean up any remaining resources..."
  docker system prune -af --volumes

  echo "âœ… Docker environment has been nuked! Only Kubernetes and BuilderKit related resources remain."
}

function docker-compose-up() {
  local compose_file="$1"
  
  if [[ -z "$compose_file" ]]; then
    echo "Error: No compose file provided"
    return 1
  fi
  
  if gum confirm "Run in detached mode?"; then
    echo "Running in detached mode..."
    docker compose -f "$compose_file" up -d
  else
    echo "Running in attached mode..."
    docker compose -f "$compose_file" up
  fi
}

# ============================================
# Go Functions
# ============================================
function go-nuke() {
  echo "ðŸš¨ WARNING: This will clean your Go module cache and {{ .chezmoi.homeDir }}/go directory ðŸš¨"
  echo "Press Ctrl+C to abort or Enter to continue..."
  read

  echo "ðŸ§¹ Cleaning Go module cache..."
  go clean -modcache

  echo "ðŸ§¼ Cleaning Go build cache..."
  go clean -cache

  echo "ðŸ—‘ï¸ Cleaning Go test cache..."
  go clean -testcache

  echo "ðŸ“¦ Removing downloaded modules in {{ .chezmoi.homeDir }}/go/pkg/mod..."
  rm -rf {{ .chezmoi.homeDir }}/go/pkg/mod/* 2>/dev/null || echo "No modules to remove."

  echo "ðŸ”¨ Removing compiled binaries in {{ .chezmoi.homeDir }}/go/bin..."
  rm -rf {{ .chezmoi.homeDir }}/go/bin/* 2>/dev/null || echo "No binaries to remove."

  echo "ðŸ§ª Removing test results..."
  find {{ .chezmoi.homeDir }}/go -name "*.test" -type f -delete

  echo "ðŸ—„ï¸ Removing temporary build files..."
  find {{ .chezmoi.homeDir }}/go -name "*.o" -type f -delete
  find {{ .chezmoi.homeDir }}/go -name "*.a" -type f -delete
  find {{ .chezmoi.homeDir }}/go -name "*.so" -type f -delete

  echo "âœ… Go environment has been nuked! Your {{ .chezmoi.homeDir }}/go directory is clean."
  echo "ðŸ‘‰ Note: Your source code in {{ .chezmoi.homeDir }}/go/src remains untouched."
}

# ============================================
# Utility Functions
# ============================================
function set_ghq_root() {
  os=$(uname)
  if [ "$os" = "Darwin" ]; then
    export GHQ_ROOT="{{ .chezmoi.homeDir }}/Developer"
  else
    export GHQ_ROOT="{{ .chezmoi.homeDir }}/code"
  fi
}
set_ghq_root

function today_format_date() {
    # Get year
    local year=$(date +%Y)
    # Get week number (01-53)
    local week=$(date +%V)
    # Get day of week (1-7 where Monday is 1)
    local day=$(date +%u)

    # Combine and echo
    echo "${year}.${week}.${day}"
}
alias tdy="today_format_date"

function today() {
    if [[ -n "$1" ]]; then
        # If date provided, parse it
        date -j -f "%Y-%m-%d" "$1" "+%Y.%V.%u" 2>/dev/null || echo "Usage: today [YYYY-MM-DD]"
    else
        # Current date
        date "+%Y.%V.%u"
    fi
}

function tmux_start() {
    local session_name="$1"
    local command="$2"
    
    # Check if session exists, create new window if it does, or create new session if it doesn't
    tmux has-session -t "$session_name" 2>/dev/null \
        && tmux new-window -t "$session_name:" -c "#{pane_current_path}" "$command" \
        || tmux new-session -d -s "$session_name" -c "#{pane_current_path}" "$command"
}

# ============================================
# Document & Media Functions
# ============================================
function md_html() {
  # Use gum for directory selection but handle errors better
  local input_dir
  input_dir=$(gum file --directory --header "Select the directory containing the markdown files") || {
    echo "Operation canceled."
    return 1
  }
  
  # Check if directory selection was canceled
  if [[ -z "$input_dir" ]]; then
    echo "Operation canceled."
    return 1
  fi
 
  # Check if input directory exists
  if [[ ! -d "$input_dir" ]]; then
    echo "Error: Directory '$input_dir' does not exist."
    return 1
  fi

   # Use gum for output file name with default
  local default_name="output.html"
  local output_file
  output_file=$(gum input --placeholder "$default_name" --header "Enter output HTML filename (or press Enter for $default_name)") || {
    echo "Operation canceled."
    return 1
  }
  output_file="${output_file:-$default_name}" 
 
  # Find markdown files
  echo "Finding markdown files..."
  local md_files=()
  while IFS= read -r line; do
    md_files+=("$line")
  done < <(find "$input_dir" -name "*.md" -o -name "*.markdown")
  
  # Check if any markdown files were found
  if [[ ${#md_files[@]} -eq 0 ]]; then
    echo "Error: No markdown files found in '$input_dir'."
    return 1
  fi
  
  echo "Found ${#md_files[@]} markdown files. Generating HTML..."
  
  # Generate HTML
  pandoc "${md_files[@]}" \
    -f markdown \
    -t html \
    -o "$output_file" \
    --highlight-style=tango \
    --self-contained \
    --metadata title="Markdown Compilation"
  
  if [[ $? -eq 0 ]]; then
    echo "âœ“ HTML successfully created: $output_file"
    
    # Ask if user wants to open the HTML
    echo "Do you want to open the HTML now? (y/n)"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      {{ if eq .chezmoi.os "darwin" -}}
      open "$output_file"
      {{ else if eq .chezmoi.os "linux" -}}
      xdg-open "$output_file" &> /dev/null
      {{ end -}}
    fi
    
    echo "You can convert this HTML to PDF using your browser's print function."
    return 0
  else
    echo "âœ— Error: Failed to create HTML."
    return 1
  fi
}

function pdf2md() {
  FILE=$(gum file --file)
  OUTPUT=$(gum input --header "Output file name (without extension): ")
  if [ -z "$OUTPUT" ]; then
    OUTPUT=$(basename "$FILE" .pdf)
  fi
  # check for file input
  if [ -f "$FILE" ]; then
   gum spin "Generating markdown" -- uvx 'markitdown[all]' "$FILE" -o "$OUTPUT.md"
   cat "$OUTPUT.md" | gum pager
  fi
}

function video_thumbnail_preview() {
  # Create a temporary directory for thumbnails
  local THUMBNAIL_DIR=$(mktemp -d)
  
  # Find all video files recursively
  find "${1:-.}" -type f -name "*.mp4" -o -name "*.mkv" -o -name "*.avi" -o -name "*.mov" -o -name "*.wmv" | while read -r video_file; do
    # Generate a unique thumbnail filename
    local thumbnail_file="$THUMBNAIL_DIR/$(basename "$video_file").jpg"
    
    # Extract thumbnail at 10% of the video duration
    ffmpeg -y -i "$video_file" -ss $(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$video_file" | awk '{print $1*0.1}') -vframes 1 "$thumbnail_file" 2>/dev/null
    
    # Add the video path to a list file with its corresponding thumbnail
    echo "$video_file:$thumbnail_file" >> "$THUMBNAIL_DIR/video_list.txt"
  done
  
  # Use fzf to preview thumbnails and select a video
  local selected_video=$(cat "$THUMBNAIL_DIR/video_list.txt" | fzf --delimiter=":" \
    --preview="kitty icat --clear --transfer-mode=file --place=\${FZF_PREVIEW_COLUMNS}x\${FZF_PREVIEW_LINES}@0x0 {2} 2>/dev/null || \
               catimg {2} 2>/dev/null || \
               chafa {2} 2>/dev/null || \
               echo 'No preview available'" \
    --preview-window="right:50%" \
    --with-nth=1 | cut -d ":" -f1)
  
  # Clean up the temporary directory
  rm -rf "$THUMBNAIL_DIR"
  
  # Return the selected video path
  if [ -n "$selected_video" ]; then
    echo "$selected_video"
  fi
}

function split_csv() {
    # Check if a file was provided
    if [ -z "$1" ]; then
        echo "Usage: split_csv <csv_file> [chunk_size]"
        return 1
    fi
    
    # Set variables
    FILE="$1"
    BASENAME=$(basename "$FILE" .csv)
    
    # Check if file exists
    if [ ! -f "$FILE" ]; then
        echo "Error: File '$FILE' not found"
        return 1
    fi
    
    # Set chunk size (default to 2000 if not specified)
    if [ -n "$2" ]; then
        CHUNK="$2"
    else 
        CHUNK=2000
    fi
    
    # Get the header
    HEADER=$(head -1 "$FILE")
    
    # Create a temporary directory for processing
    TEMP_DIR=$(mktemp -d)
    
    # Split the file (excluding header)
    tail -n +2 "$FILE" | split -l "$CHUNK" - "$TEMP_DIR/${BASENAME}_"
    
    # Add header to each file and rename with proper numbering
    COUNT=1
    for i in "$TEMP_DIR/${BASENAME}_"*; do
        # Create output filename with padding (01, 02, etc.)
        OUTPUT_FILE="${BASENAME}_$(printf "%02d" $COUNT).csv"
        
        # Add header and save to final location
        echo "$HEADER" > "$OUTPUT_FILE"
        cat "$i" >> "$OUTPUT_FILE"
        
        echo "Created: $OUTPUT_FILE"
        COUNT=$((COUNT + 1))
    done
    
    # Clean up temporary files
    rm -rf "$TEMP_DIR"
    
    echo "Split complete: $((COUNT-1)) files created with $CHUNK rows each (except possibly the last file)"
}

function url_preview() {
  if [[ -z "$1" ]]; then
    echo "Usage: url_preview <url>"
    return 1
  fi

  local url="$1"
  local cache_dir="${XDG_CACHE_HOME:-{{ .chezmoi.homeDir }}/.cache}/url_preview"
  local cache_file="$cache_dir/$(echo "$url" | md5sum | cut -d' ' -f1)"
  
  # Create cache directory if it doesn't exist
  mkdir -p "$cache_dir"
  
  # Check if cached result exists and is less than 24 hours old
  if [[ -f "$cache_file" && $(($(date +%s) - $(stat -c %Y "$cache_file"))) -lt 86400 ]]; then
    cat "$cache_file"
    return 0
  fi
  
  # Use curl with timeout and limited download
  local html=$(curl -s -L --max-filesize 50000 --connect-timeout 3 --max-time 5 "$url" | 
               grep -A 100 "<head" | grep -B 100 "</head>" 2>/dev/null)
  
  # Extract all metadata in a single pass
  local title=$(echo "$html" | grep -o '<meta property="og:title" content="[^"]*"\|<title>[^<]*</title>' | 
                sed -E 's/<meta property="og:title" content="([^"]*)"|<title>([^<]*)<\/title>/\1\2/' | head -1)
  
  local description=$(echo "$html" | grep -o '<meta property="og:description" content="[^"]*"\|<meta name="description" content="[^"]*"' | 
                      sed -E 's/<meta property="og:description" content="([^"]*)"|<meta name="description" content="([^"]*)"/\1\2/' | head -1)
  
  local labels=$(echo "$html" | grep -o '<meta property="og:keywords" content="[^"]*"\|<meta name="keywords" content="[^"]*"' | 
                 sed -E 's/<meta property="og:keywords" content="([^"]*)"|<meta name="keywords" content="([^"]*)"/\1\2/' | head -1)
  
  local category=$(echo "$html" | grep -o '<meta property="og:type" content="[^"]*"\|<meta name="category" content="[^"]*"' | 
                   sed -E 's/<meta property="og:type" content="([^"]*)"|<meta name="category" content="([^"]*)"/\1\2/' | head -1)
  
  # Set default values if not found
  [[ -z "$title" ]] && title="No title found"
  [[ -z "$description" ]] && description="No description found"
  [[ -z "$labels" ]] && labels="No labels found"
  [[ -z "$category" ]] && category="No category found"
  
  # Format with gum
  local output=$(gum format "# $title" "> $labels" "$description" "### $category")
  
  # Cache the result
  echo "$output" > "$cache_file"
  
  # Output the result
  echo "$output"
}

# ============================================
# Environment Specific
# ============================================
{{ if eq .chezmoi.os "darwin" -}}
export NVM_DIR="{{ .chezmoi.homeDir }}/.nvm"
  [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && \. "/opt/homebrew/opt/nvm/nvm.sh"  # This loads nvm
  [ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"  # This loads nvm bash_completion

if [ -d "/opt/homebrew/opt/ruby/bin" ]; then
  export PATH=/opt/homebrew/opt/ruby/bin:$PATH
  export PATH=`gem environment gemdir`/bin:$PATH
fi

export PATH="/usr/local/opt/libpq/bin:$PATH"
export PATH="/opt/homebrew/opt/libpq/bin:$PATH"
{{ end -}}

# ============================================
# Tmuxinator
# ============================================
alias tts='tmuxinator start $(tmuxinator list | tail -n +2 | tr -s " " "\n" | fzf --reverse --header "Select a tmuxinator session")'

# ============================================
# Task Runner
# ============================================
alias ght='git_root=$(git rev-parse --show-toplevel 2>/dev/null) && taskfile="$git_root/.github/Taskfile.yml" && [ -f "$taskfile" ] && task -t "$taskfile" "$@" || echo "No Taskfile.yml found in .github directory of git repository"'

# ============================================
# Completion
# ============================================
{{ if eq .chezmoi.os "darwin" -}}
## [Completion]
## Completion scripts setup. Remove the following line to uninstall
[[ -f {{ .chezmoi.homeDir }}/.config/.dart-cli-completion/zsh-config.zsh ]] && . {{ .chezmoi.homeDir }}/.config/.dart-cli-completion/zsh-config.zsh || true

function sesh-sessions() {
  {
    exec </dev/tty
    exec <&1
    local session
    session=$(sesh list -t -c | fzf --height 40% --reverse --border-label ' sesh ' --border --prompt 'âš¡  ')
    zle reset-prompt > /dev/null 2>&1 || true
    [[ -z "$session" ]] && return
    sesh connect $session
  }
}

zle     -N             sesh-sessions
bindkey -M emacs '\es' sesh-sessions
bindkey -M vicmd '\es' sesh-sessions
bindkey -M viins '\es' sesh-sessions

{{ end -}}

