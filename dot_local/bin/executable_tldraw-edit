#!/usr/bin/env bash
# tldraw-edit - Edit .tldr files in the browser

set -e

VERSION="1.0.0"

show_help() {
    cat <<EOF
tldraw-edit - Edit .tldr files in the browser

Usage: tldraw-edit [OPTIONS] <file.tldr>

Options:
    -h, --help     Show this help message
    -v, --version  Show version
    -p, --port     Specify port (default: auto-select)

Examples:
    tldraw-edit drawings.tldr
    tldraw-edit -p 3000 drawings.tldr
    tldraw-edit ./path/to/drawings.tldr

EOF
}

# Parse arguments
PORT=""
TLDR_FILE=""

while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
        show_help
        exit 0
        ;;
    -v | --version)
        echo "tldraw-edit version $VERSION"
        exit 0
        ;;
    -p | --port)
        PORT="$2"
        shift 2
        ;;
    *)
        TLDR_FILE="$1"
        shift
        ;;
    esac
done

# Validate file argument
if [ -z "$TLDR_FILE" ]; then
    echo "Error: No .tldr file specified"
    show_help
    exit 1
fi

# Convert to absolute path
TLDR_FILE=$(realpath "$TLDR_FILE")

# Check if file exists
if [ ! -f "$TLDR_FILE" ]; then
    echo "Error: File not found: $TLDR_FILE"
    exit 1
fi

# Find an available port if not specified
if [ -z "$PORT" ]; then
    PORT=3000
    while lsof -Pi :$PORT -sTCP:LISTEN -t >/dev/null 2>&1; do
        PORT=$((PORT + 1))
    done
fi

echo "Starting tldraw editor for: $TLDR_FILE"
echo "Port: $PORT"

# Create temporary directory
TMP_DIR=$(mktemp -d)
TMP_HTML="$TMP_DIR/tldraw.html"
TMP_SERVER="$TMP_DIR/server.js"

# Generate unique service name based on file
BASENAME=$(basename "$TLDR_FILE" .tldr)
SERVICE_NAME="tldraw-edit-${BASENAME}-${PORT}"

# Cleanup function
cleanup() {
    echo ""
    echo "Shutting down tldraw editor..."
    if systemctl --user is-active "$SERVICE_NAME" &>/dev/null; then
        systemctl --user stop "$SERVICE_NAME"
    fi
    rm -rf "$TMP_DIR"
    exit 0
}

trap cleanup SIGINT SIGTERM EXIT

# Create HTML file
cat >"$TMP_HTML" <<'HTMLEOF'
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>tldraw Editor</title>
    <link rel="stylesheet" href="https://esm.sh/@tldraw/tldraw@2.4.0/tldraw.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
        }
        #container {
            position: fixed;
            inset: 0;
        }
        #status {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="status">Loading...</div>
    <script type="module">
        import { Tldraw } from 'https://esm.sh/@tldraw/tldraw@2.4.0?deps=react@18.3.1,react-dom@18.3.1'
        import { createRoot } from 'https://esm.sh/react-dom@18.3.1?deps=react@18.3.1'
        import { createElement } from 'https://esm.sh/react@18.3.1'

        const status = document.getElementById('status')
        let saveTimeout = null
        let snapshot = null
        let editor = null

        function updateStatus(message, type = 'normal') {
            status.textContent = message
            status.className = type
        }

        // Load snapshot from server
        async function loadSnapshot() {
            try {
                updateStatus('Loading snapshot...', 'normal')
                console.log('Fetching snapshot...')
                const response = await fetch('/snapshot')
                console.log('Response status:', response.status)

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`)
                }

                snapshot = await response.json()
                console.log('Snapshot loaded, keys:', Object.keys(snapshot))
                initEditor()
            } catch (e) {
                console.error('Failed to load snapshot:', e)
                updateStatus('Failed to load file ✗', 'error')
            }
        }

        function initEditor() {
            console.log('Initializing editor with snapshot')
            updateStatus('Initializing editor...', 'normal')

            const root = createRoot(document.getElementById('container'))

            root.render(
                createElement(Tldraw, {
                    snapshot: snapshot,
                    onMount: (ed) => {
                        console.log('Editor mounted')
                        editor = ed
                        updateStatus('Ready')

                        // Auto-save on changes with debounce
                        editor.store.listen((entry) => {
                            clearTimeout(saveTimeout)
                            saveTimeout = setTimeout(() => {
                                saveToFile()
                                exportAllPagesSvg()
                            }, 1000)
                        })
                    }
                })
            )
        }

        // Start loading
        loadSnapshot()

        async function saveToFile() {
            if (!editor) return

            try {
                updateStatus('Saving...', 'normal')
                const currentSnapshot = editor.store.getSnapshot()

                const response = await fetch('/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(currentSnapshot)
                })

                if (response.ok) {
                    updateStatus('Saved ✓', 'saved')
                    setTimeout(() => updateStatus('Ready'), 2000)
                } else {
                    throw new Error('Save failed')
                }
            } catch (e) {
                console.error('Save failed:', e)
                updateStatus('Save failed ✗', 'error')
            }
        }

        async function exportAllPagesSvg() {
            if (!editor) return

            try {
                const pages = editor.getPages()
                console.log(`Exporting ${pages.length} pages as SVG...`)

                for (const page of pages) {
                    // Switch to the page
                    editor.setCurrentPage(page.id)

                    // Get all shapes on this page
                    const shapes = editor.getCurrentPageShapes()
                    if (shapes.length === 0) continue

                    // Get the SVG
                    const svg = await editor.getSvg(shapes.map(s => s.id))
                    if (!svg) continue

                    const svgString = new XMLSerializer().serializeToString(svg)

                    // Send to server
                    await fetch('/export-svg', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            pageName: page.name || `page-${page.index}`,
                            svg: svgString
                        })
                    })
                }

                console.log('SVG export complete')
            } catch (e) {
                console.error('SVG export failed:', e)
            }
        }

        // Manual save with Ctrl+S
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault()
                saveToFile()
            }
        })
    </script>
</body>
</html>
HTMLEOF

# Create Node.js server
cat >"$TMP_SERVER" <<SERVEREOF
const http = require('http');
const fs = require('fs');
const path = require('path');

const tldrFile = '$TLDR_FILE';
const htmlFile = '$TMP_HTML';
const port = $PORT;

// Create SVG export directory
const tldrDir = path.dirname(tldrFile);
const tldrBasename = path.basename(tldrFile, '.tldr');
const svgExportDir = path.join(tldrDir, tldrBasename);

if (!fs.existsSync(svgExportDir)) {
    fs.mkdirSync(svgExportDir, { recursive: true });
    console.log('Created SVG export directory:', svgExportDir);
}

const server = http.createServer((req, res) => {
    // Enable CORS
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
    }

    if (req.url === '/' || req.url === '/index.html') {
        try {
            const html = fs.readFileSync(htmlFile, 'utf8');
            res.writeHead(200, { 'Content-Type': 'text/html' });
            res.end(html);
        } catch (e) {
            res.writeHead(500);
            res.end('Error loading editor');
        }
    } else if (req.url === '/snapshot' && req.method === 'GET') {
        try {
            const snapshot = fs.readFileSync(tldrFile, 'utf8');
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(snapshot);
        } catch (e) {
            console.error('Load error:', e);
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: e.message }));
        }
    } else if (req.url === '/save' && req.method === 'POST') {
        let body = '';
        req.on('data', chunk => { body += chunk.toString(); });
        req.on('end', () => {
            try {
                // Validate JSON
                JSON.parse(body);
                fs.writeFileSync(tldrFile, body);
                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ success: true }));
            } catch (e) {
                console.error('Save error:', e);
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: e.message }));
            }
        });
    } else if (req.url === '/export-svg' && req.method === 'POST') {
        let body = '';
        req.on('data', chunk => { body += chunk.toString(); });
        req.on('end', () => {
            try {
                const data = JSON.parse(body);
                const svgFilename = \`\${data.pageName.replace(/[^a-z0-9_-]/gi, '_')}.svg\`;
                const svgPath = path.join(svgExportDir, svgFilename);

                fs.writeFileSync(svgPath, data.svg);
                console.log('Exported SVG:', svgFilename);

                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ success: true, path: svgPath }));
            } catch (e) {
                console.error('SVG export error:', e);
                res.writeHead(500, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: e.message }));
            }
        });
    } else {
        res.writeHead(404);
        res.end('Not found');
    }
});

server.listen(port, 'localhost', () => {
    console.log(\`Server running at http://localhost:\${port}\`);
});

process.on('SIGTERM', () => {
    server.close();
    process.exit(0);
});
SERVEREOF

# Start the server using systemd-run
echo "Server running at http://localhost:$PORT"
systemd-run --user \
    --unit="$SERVICE_NAME" \
    --description="TLDraw Editor for $BASENAME" \
    --collect \
    node "$TMP_SERVER"

# Wait for server to start
sleep 2

# Check if server is running
if ! systemctl --user is-active "$SERVICE_NAME" &>/dev/null; then
    echo "Error: Failed to start server"
    cleanup
    exit 1
fi

# Open in browser
URL="http://localhost:$PORT"
echo "Opening browser at $URL"
omarchy-launch-webapp "$URL"

# Keep script running and monitor server
echo "Press Ctrl+C to stop the server"
while systemctl --user is-active "$SERVICE_NAME" &>/dev/null; do
    sleep 1
done

# Auto cleanup when server stops
cleanup
