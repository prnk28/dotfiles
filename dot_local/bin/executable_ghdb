#!/bin/bash

# DuckDB Data Insertion Script
# Functions for inserting commit history, PR details, and documentation

set -euo pipefail

# Configuration
CWD=$(pwd)
DATA_DIR="$HOME/.local/share/github/data"
GITHUB_API_BASE="https://api.github.com"

# Dynamically determine repository name and database file
get_repo_db() {
    if git rev-parse --git-dir >/dev/null 2>&1; then
        local repo_name=$(basename "$(git rev-parse --show-toplevel)")
        echo "$DATA_DIR/${repo_name}.duckdb"
    else
        log_error "Not in a git repository"
        exit 1
    fi
}

# Get repository owner/name from git remote
get_repo_slug() {
    local remote_url
    remote_url=$(git config --get remote.origin.url 2>/dev/null)
    
    if [ -z "$remote_url" ]; then
        return 1
    fi
    
    # Handle both SSH and HTTPS URLs
    # SSH: git@github.com:owner/repo.git
    # HTTPS: https://github.com/owner/repo.git
    if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/\.]+) ]]; then
        echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
        return 0
    fi
    
    return 1
}

# Get default branch name
get_default_branch() {
    # Try to get from remote HEAD
    local default_branch
    default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
    
    if [ -z "$default_branch" ]; then
        # Fallback to common defaults
        if git show-ref --verify --quiet refs/heads/main; then
            echo "main"
        elif git show-ref --verify --quiet refs/heads/master; then
            echo "master"
        else
            echo "HEAD"
        fi
    else
        echo "$default_branch"
    fi
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Utility functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if required tools are installed
check_dependencies() {
    local missing_deps=()

    if ! command -v duckdb &>/dev/null; then
        missing_deps+=("duckdb")
    fi

    if ! command -v git &>/dev/null; then
        missing_deps+=("git")
    fi

    if ! command -v curl &>/dev/null; then
        missing_deps+=("curl")
    fi

    if [ ${#missing_deps[@]} -ne 0 ]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        log_info "Please install the missing tools and try again."
        exit 1
    fi
}

# Initialize DuckDB database with tables
init_database() {
    mkdir -p "$DATA_DIR"
    local db_file="$(get_repo_db)"

    log_info "Initializing database: $db_file"

    duckdb "$db_file" <<'EOF'
-- Create commits table
CREATE TABLE IF NOT EXISTS commits (
    hash VARCHAR PRIMARY KEY,
    author_name VARCHAR,
    author_email VARCHAR,
    author_date TIMESTAMP,
    committer_name VARCHAR,
    committer_email VARCHAR,
    committer_date TIMESTAMP,
    subject VARCHAR,
    body TEXT,
    files_changed INTEGER,
    insertions INTEGER,
    deletions INTEGER,
    branch VARCHAR,
    inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create pull_requests table
CREATE TABLE IF NOT EXISTS pull_requests (
    number INTEGER PRIMARY KEY,
    title VARCHAR,
    body TEXT,
    state VARCHAR,
    author VARCHAR,
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    closed_at TIMESTAMP,
    merged_at TIMESTAMP,
    base_branch VARCHAR,
    head_branch VARCHAR,
    url VARCHAR,
    repository VARCHAR,
    insertions INTEGER,
    deletions INTEGER,
    changed_files INTEGER,
    inserted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create documentation table
CREATE TABLE IF NOT EXISTS documentation (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    source_uri VARCHAR,
    title VARCHAR,
    content TEXT,
    content_type VARCHAR,
    fetched_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    size_bytes INTEGER,
    checksum VARCHAR
);

.mode duckbox
SELECT 'Database initialized successfully' AS status;
EOF

    log_success "Database initialized with tables: commits, pull_requests, documentation"
    
    # Automatically load initial data
    local default_branch=$(get_default_branch)
    log_info "Loading last 100 commits from $default_branch branch..."
    insert_commit_history 100 "$default_branch"
    
    # Load merged PRs if we can get the repo slug
    local repo_slug
    if repo_slug=$(get_repo_slug); then
        log_info "Loading last 20 merged PRs from $repo_slug..."
        fetch_merged_prs "$repo_slug" 20
    else
        log_warning "Could not determine repository owner/name from remote. Skipping PR import."
    fi
}

# Function 1: Insert commit history on current branch
insert_commit_history() {
    local db_file="$(get_repo_db)"
    local limit="${1:-50}"
    local branch="${2:-$(git rev-parse --abbrev-ref HEAD)}"

    log_info "Fetching commit history for branch: $branch (limit: $limit)"

    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not in a git repository"
        return 1
    fi

    # Create temporary CSV file with proper formatting
    local temp_csv=$(mktemp)
    
    # Write CSV header
    echo "hash,author_name,author_email,author_date,committer_name,committer_email,committer_date,subject,body,files_changed,insertions,deletions,branch" > "$temp_csv"
    
    # Process each commit individually to handle multiline commit messages
    local commit_count=0
    while IFS= read -r commit_hash; do
        [ -z "$commit_hash" ] && continue
        
        # Get commit details
        local author_name=$(git log -1 --format="%an" "$commit_hash")
        local author_email=$(git log -1 --format="%ae" "$commit_hash")
        local author_date=$(git log -1 --format="%aI" "$commit_hash")
        local committer_name=$(git log -1 --format="%cn" "$commit_hash")
        local committer_email=$(git log -1 --format="%ce" "$commit_hash")
        local committer_date=$(git log -1 --format="%cI" "$commit_hash")
        local subject=$(git log -1 --format="%s" "$commit_hash" | sed 's/"/""/g')
        local body=$(git log -1 --format="%b" "$commit_hash" | sed 's/"/""/g' | tr '\n' ' ')
        
        # Get stats
        local stats=$(git diff-tree --no-commit-id --numstat -r "$commit_hash" 2>/dev/null)
        local files_changed=0
        local insertions=0
        local deletions=0
        
        if [ -n "$stats" ]; then
            files_changed=$(echo "$stats" | wc -l)
            insertions=$(echo "$stats" | awk '{sum+=$1} END {print sum+0}')
            deletions=$(echo "$stats" | awk '{sum+=$2} END {print sum+0}')
        fi
        
        # Write to CSV
        echo "\"$commit_hash\",\"$author_name\",\"$author_email\",\"$author_date\",\"$committer_name\",\"$committer_email\",\"$committer_date\",\"$subject\",\"$body\",$files_changed,$insertions,$deletions,\"$branch\"" >> "$temp_csv"
        
        ((commit_count++))
    done < <(git rev-list --max-count="$limit" "$branch" --no-merges 2>/dev/null)
    
    if [ $commit_count -eq 0 ]; then
        log_warning "No commits found on branch $branch"
        rm "$temp_csv"
        return 0
    fi

    # Insert into DuckDB
    duckdb "$db_file" <<EOF
COPY commits 
FROM '$temp_csv' 
(FORMAT CSV, HEADER true, DELIMITER ',', QUOTE '"', ESCAPE '"');

SELECT COUNT(*) as inserted_commits FROM commits WHERE branch = '$branch';
EOF

    rm "$temp_csv"
    log_success "Commit history inserted for branch: $branch"
}

# Function 2: Insert PR details
insert_pr_details() {
    local db_file="$(get_repo_db)"
    local repo="$1"
    local pr_number="$2"
    local github_token="${GITHUB_TOKEN:-}"

    if [ -z "$repo" ]; then
        log_error "Repository not specified (format: owner/repo)"
        return 1
    fi

    if [ -z "$pr_number" ]; then
        log_error "PR number not specified"
        return 1
    fi

    log_info "Fetching PR #$pr_number from $repo"

    # Build curl command with optional authentication
    local curl_cmd="curl -s"
    if [ -n "$github_token" ]; then
        curl_cmd="$curl_cmd -H 'Authorization: token $github_token'"
    fi

    # Fetch PR details
    local pr_data
    pr_data=$(eval "$curl_cmd '$GITHUB_API_BASE/repos/$repo/pulls/$pr_number'")

    if echo "$pr_data" | grep -q '"message": "Not Found"'; then
        log_error "PR #$pr_number not found in $repo"
        return 1
    fi

    # Create temporary JSON file
    local temp_json=$(mktemp)
    echo "$pr_data" >"$temp_json"

    # Insert into DuckDB using JSON functions
    duckdb "$db_file" <<EOF
INSERT OR REPLACE INTO pull_requests (
    number, title, body, state, author, created_at, updated_at, 
    closed_at, merged_at, base_branch, head_branch, url, repository,
    insertions, deletions, changed_files
)
SELECT 
    json_extract(j, '$.number')::INTEGER as number,
    json_extract(j, '$.title') as title,
    json_extract(j, '$.body') as body,
    json_extract(j, '$.state') as state,
    json_extract(j, '$.user.login') as author,
    strptime(json_extract(j, '$.created_at'), '%Y-%m-%dT%H:%M:%SZ') as created_at,
    strptime(json_extract(j, '$.updated_at'), '%Y-%m-%dT%H:%M:%SZ') as updated_at,
    CASE 
        WHEN json_extract(j, '$.closed_at') IS NULL THEN NULL 
        ELSE strptime(json_extract(j, '$.closed_at'), '%Y-%m-%dT%H:%M:%SZ')
    END as closed_at,
    CASE 
        WHEN json_extract(j, '$.merged_at') IS NULL THEN NULL 
        ELSE strptime(json_extract(j, '$.merged_at'), '%Y-%m-%dT%H:%M:%SZ')
    END as merged_at,
    json_extract(j, '$.base.ref') as base_branch,
    json_extract(j, '$.head.ref') as head_branch,
    json_extract(j, '$.html_url') as url,
    '$repo' as repository,
    json_extract(j, '$.additions')::INTEGER as insertions,
    json_extract(j, '$.deletions')::INTEGER as deletions,
    json_extract(j, '$.changed_files')::INTEGER as changed_files
FROM (
    SELECT json(content) as j 
    FROM read_text('$temp_json')
);

SELECT 'PR #' || number || ' inserted successfully' as status 
FROM pull_requests 
WHERE number = $pr_number AND repository = '$repo';
EOF

    rm "$temp_json"
    log_success "PR #$pr_number details inserted from $repo"
}

# Function to fetch multiple merged PRs
fetch_merged_prs() {
    local repo="$1"
    local limit="${2:-20}"
    local db_file="$(get_repo_db)"
    local github_token="${GITHUB_TOKEN:-}"
    
    if [ -z "$repo" ]; then
        log_error "Repository not specified (format: owner/repo)"
        return 1
    fi
    
    log_info "Fetching last $limit merged PRs from $repo"
    
    # Build curl command with optional authentication
    local curl_cmd="curl -s"
    if [ -n "$github_token" ]; then
        curl_cmd="$curl_cmd -H 'Authorization: token $github_token'"
    fi
    
    # Fetch merged PRs (GitHub API returns them in descending order by default)
    local pr_list
    pr_list=$(eval "$curl_cmd '$GITHUB_API_BASE/repos/$repo/pulls?state=closed&sort=updated&direction=desc&per_page=$limit'")
    
    if echo "$pr_list" | grep -q '"message": "Not Found"'; then
        log_error "Repository $repo not found or not accessible"
        return 1
    fi
    
    # Create temporary JSON file
    local temp_json=$(mktemp)
    echo "$pr_list" >"$temp_json"
    
    # Insert all PRs that are merged
    duckdb "$db_file" <<EOF
INSERT OR REPLACE INTO pull_requests (
    number, title, body, state, author, created_at, updated_at,
    closed_at, merged_at, base_branch, head_branch, url, repository
)
SELECT 
    json_extract(j, '$.number')::INTEGER as number,
    json_extract(j, '$.title') as title,
    json_extract(j, '$.body') as body,
    json_extract(j, '$.state') as state,
    json_extract(j, '$.user.login') as author,
    strptime(json_extract(j, '$.created_at'), '%Y-%m-%dT%H:%M:%SZ') as created_at,
    strptime(json_extract(j, '$.updated_at'), '%Y-%m-%dT%H:%M:%SZ') as updated_at,
    CASE 
        WHEN json_extract(j, '$.closed_at') IS NULL THEN NULL 
        ELSE strptime(json_extract(j, '$.closed_at'), '%Y-%m-%dT%H:%M:%SZ')
    END as closed_at,
    CASE 
        WHEN json_extract(j, '$.merged_at') IS NULL THEN NULL 
        ELSE strptime(json_extract(j, '$.merged_at'), '%Y-%m-%dT%H:%M:%SZ')
    END as merged_at,
    json_extract(j, '$.base.ref') as base_branch,
    json_extract(j, '$.head.ref') as head_branch,
    json_extract(j, '$.html_url') as url,
    '$repo' as repository
FROM (
    SELECT unnest(json(content)) as j
    FROM read_text('$temp_json')
)
WHERE json_extract(j, '$.merged_at') IS NOT NULL;

SELECT COUNT(*) || ' merged PRs inserted' as status 
FROM pull_requests 
WHERE repository = '$repo' AND merged_at IS NOT NULL;
EOF
    
    rm "$temp_json"
    log_success "Merged PRs fetched from $repo"
}

# Function 3: Insert documentation from URI source
insert_documentation() {
    local db_file="$(get_repo_db)"
    local uri="$1"
    local title="${2:-}"

    if [ -z "$uri" ]; then
        log_error "URI not specified"
        return 1
    fi

    log_info "Fetching documentation from: $uri"

    # Determine content type and fetch content
    local content_type
    local temp_content=$(mktemp)

    # Fetch with curl and get content type
    if curl -s -L -w "%{content_type}" -o "$temp_content" "$uri"; then
        content_type=$(curl -s -L -w "%{content_type}" -o /dev/null "$uri" | cut -d';' -f1)
    else
        log_error "Failed to fetch content from $uri"
        rm "$temp_content"
        return 1
    fi

    # Extract title if not provided
    if [ -z "$title" ]; then
        case "$content_type" in
        "text/html")
            title=$(grep -i '<title>' "$temp_content" | sed 's/<[^>]*>//g' | xargs || echo "Untitled")
            ;;
        "text/markdown" | "text/plain")
            title=$(head -n 1 "$temp_content" | sed 's/^#*\s*//' || basename "$uri")
            ;;
        *)
            title=$(basename "$uri")
            ;;
        esac
    fi

    # Calculate size and checksum
    local size_bytes
    local checksum
    size_bytes=$(wc -c <"$temp_content")
    checksum=$(sha256sum "$temp_content" | cut -d' ' -f1)

    # Insert into DuckDB
    duckdb "$db_file" <<EOF
INSERT INTO documentation (source_uri, title, content, content_type, size_bytes, checksum)
VALUES (
    '$uri',
    '$title',
    (SELECT content FROM read_text('$temp_content')),
    '$content_type',
    $size_bytes,
    '$checksum'
);

SELECT 'Documentation inserted: ' || title as status 
FROM documentation 
WHERE source_uri = '$uri' 
ORDER BY fetched_at DESC 
LIMIT 1;
EOF

    rm "$temp_content"
    log_success "Documentation inserted from: $uri"
}

# Helper function to query data
query_data() {
    local db_file="$(get_repo_db)"
    local table="$1"
    local limit="${2:-10}"

    case "$table" in
    "commits")
        duckdb "$db_file" -c "SELECT hash[1:8] as short_hash, author_name, author_date, subject FROM commits ORDER BY author_date DESC LIMIT $limit;"
        ;;
    "pull_requests" | "prs")
        duckdb "$db_file" -c "SELECT number, title, state, author, created_at FROM pull_requests ORDER BY created_at DESC LIMIT $limit;"
        ;;
    "documentation" | "docs")
        duckdb "$db_file" -c "SELECT title, source_uri, content_type, size_bytes, fetched_at FROM documentation ORDER BY fetched_at DESC LIMIT $limit;"
        ;;
    *)
        log_error "Unknown table: $table. Available: commits, pull_requests, documentation"
        return 1
        ;;
    esac
}

# Main function to show usage
show_usage() {
    cat <<'EOF'
DuckDB Data Insertion Script

Usage:
    ghdb init                                      # Initialize database for current repo
    ghdb commits [limit] [branch]                 # Insert commit history
    ghdb pr owner/repo pr_number                  # Insert PR details
    ghdb docs uri [title]                         # Insert documentation
    ghdb query table [limit]                      # Query data

Environment Variables:
    GITHUB_TOKEN    # GitHub API token for private repositories

Examples:
    ghdb init                                    # Initialize database for current repo
    ghdb commits 100 main                       # Insert 100 commits from main branch
    ghdb pr microsoft/vscode 1234               # Insert PR #1234
    ghdb docs https://example.com/docs "API Documentation"
    ghdb query commits 5                        # Show 5 recent commits

EOF
}

# Main script logic
main() {
    local command="$1"
    shift

    check_dependencies

    case "$command" in
    "init")
        init_database "$@"
        ;;
    "commits")
        insert_commit_history "$@"
        ;;
    "pr")
        insert_pr_details "$@"
        ;;
    "docs")
        insert_documentation "$@"
        ;;
    "query")
        query_data "$@"
        ;;
    "help" | "-h" | "--help")
        show_usage
        ;;
    *)
        log_error "Unknown command: $command"
        show_usage
        exit 1
        ;;
    esac
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    if [ $# -eq 0 ]; then
        show_usage
        exit 1
    fi
    main "$@"
fi
